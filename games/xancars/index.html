<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>XanCars</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #111;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }
    canvas { display: block; }
    .home-btn {
      position: fixed;
      top: 12px;
      left: 12px;
      z-index: 100;
      background: rgba(0,0,0,0.65);
      color: #FFD60A;
      text-decoration: none;
      font: bold 13px sans-serif;
      padding: 6px 12px;
      border-radius: 8px;
      border: 1px solid #FFD60A44;
    }
    .home-btn:hover { background: rgba(255,214,10,0.15); }
  </style>
</head>
<body>
<a href="../../index.html" class="home-btn">âš¡ ZapZone</a>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx    = canvas.getContext('2d');

const W = 480, H = 640;
canvas.width  = W;
canvas.height = H;

// â”€â”€ Road layout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const ROAD_L = 70;
const ROAD_R = W - 70;

// â”€â”€ Input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const keys = {};
window.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code))
    e.preventDefault();
  if (gameOver && (e.code === 'Enter' || e.code === 'Space')) startGame();
});
window.addEventListener('keyup', e => { keys[e.code] = false; });

canvas.addEventListener('click', e => {
  if (!gameOver) return;
  const r  = canvas.getBoundingClientRect();
  const cx = (e.clientX - r.left) * (W / r.width);
  const cy = (e.clientY - r.top)  * (H / r.height);
  const _ph = (score + kills * 5) > highScore ? 290 : 265;
  const _btnY = H/2 - _ph/2 + _ph - 66;
  if (cx > W/2-90 && cx < W/2+90 && cy > _btnY && cy < _btnY + 44) startGame();
});

// â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let gameOver, score, startTime, scrollY;
let highScore = parseInt(localStorage.getItem('xancars_hs') || '0');

const player = { x: W/2, y: H - 140, w: 36, h: 62, speed: 8 };

// â”€â”€ Enemies â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let enemies    = [];
let spawnTimer = 0;
const BASE_SPAWN_INTERVAL = 150;  // was 110 â€” easier level 1
const BASE_ENEMY_SPEED    = 3.2;  // was 6.4

// â”€â”€ Bullets & Explosions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let bullets       = [];
let explosions    = [];
let shootCooldown = 0;
let kills         = 0;
const BULLET_SPEED   = 18;
const SHOOT_COOLDOWN = 12;

let enemyBullets = [];
const ENEMY_BULLET_SPEED = 7;    // was 12
const ENEMY_SHOOT_MIN    = 90;
const ENEMY_SHOOT_MAX    = 180;

// â”€â”€ Tanks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let tanks          = [];
let tankBullets    = [];
let tankSpawnTimer = 0;
const BASE_TANK_INTERVAL = 380;
const TANK_MAX_HP        = 5;
const TANK_W             = 54;
const TANK_H             = 56;
const TANK_SHOOT_MIN     = 55;
const TANK_SHOOT_MAX     = 110;
const TANK_BULLET_SPEED  = 6;    // was 10

// â”€â”€ Levels & Obstacles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let obstacles        = [];
let obstacleTimer    = 0;
let lastLevel        = 1;
let bannerLevel      = 1;
let levelBannerTimer = 0;
const BASE_SCROLL            = 5;   // was 10
const BASE_OBSTACLE_INTERVAL = 240; // was 180

// â”€â”€ Power-ups & Mines â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const POWERUP_DURATION       = 480;  // 8 sec @ 60 fps
const SHIELD_DURATION        = 360;  // 6 sec
const POWERUP_SPAWN_INTERVAL = 540;  // ~9 sec periodic
const ENEMY_DROP_CHANCE      = 0.20; // 20% on kill

let powerups          = [];
let mines             = [];
let powerupSpawnTimer = 0;
let shieldTimer       = 0;
let rapidFireTimer    = 0;
let tripleTimer       = 0;
let bombFlash         = 0;

// â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getLevel()     { return Math.min(10, Math.floor(score / 25) + 1); }
function getLevelMult() { return 1 + (getLevel() - 1) * 0.2; }

// â”€â”€ Spawners â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnObstacle() {
  const vy   = BASE_SCROLL * getLevelMult();
  const type = ['cone', 'oil', 'barrier'][Math.floor(Math.random() * 3)];
  if (type === 'cone') {
    const x = ROAD_L + 25 + Math.random() * (ROAD_R - ROAD_L - 50);
    obstacles.push({ type, x, y: -30, w: 18, h: 24, vy });
  } else if (type === 'oil') {
    const x = ROAD_L + 50 + Math.random() * (ROAD_R - ROAD_L - 100);
    obstacles.push({ type, x, y: -20, w: 72, h: 22, vy });
  } else {
    const gapW = 68;
    const gapX = ROAD_L + 15 + Math.random() * (ROAD_R - ROAD_L - 30 - gapW);
    obstacles.push({ type, x: ROAD_L, y: -20, w: ROAD_R - ROAD_L, h: 20, gapX, gapW, vy });
  }
}

function spawnEnemy() {
  const lv     = getLevel();
  const margin = player.w;
  const x      = ROAD_L + margin + Math.random() * (ROAD_R - ROAD_L - margin * 2);
  const shootTimer = ENEMY_SHOOT_MIN + Math.floor(Math.random() * (ENEMY_SHOOT_MAX - ENEMY_SHOOT_MIN));

  // Gate new types behind level thresholds
  let type = 'normal';
  const roll = Math.random();
  if      (lv >= 9 && roll < 0.15) type = 'bomber';
  else if (lv >= 7 && roll < 0.30) type = 'armored';
  else if (lv >= 5 && roll < 0.45) type = 'zigzag';

  const e = { x, y: -40, w: 36, h: 62, shootTimer, type };

  if (type === 'zigzag') {
    e.t       = 0;
    e.xAmp    = 22 + Math.random() * 14;
    e.xCenter = Math.max(ROAD_L + e.xAmp + 10, Math.min(ROAD_R - e.xAmp - 10, x));
    e.xFreq   = 0.045 + Math.random() * 0.025;
  } else if (type === 'armored') {
    e.hp       = 3;
    e.hitFlash = 0;
    e.w        = 40;
  } else if (type === 'bomber') {
    e.bombTimer = 80 + Math.floor(Math.random() * 60);
    e.w         = 42;
    e.h         = 60;
  }

  enemies.push(e);
}

function spawnTank() {
  const margin  = TANK_W / 2 + 10;
  const roadW   = ROAD_R - ROAD_L;
  const xCenter = ROAD_L + margin + Math.random() * (roadW - margin * 2);
  const xAmp    = Math.max(20, Math.min(xCenter - ROAD_L - margin, ROAD_R - xCenter - margin, 70));
  tanks.push({
    x: xCenter, y: -TANK_H,
    w: TANK_W,  h: TANK_H,
    hp: TANK_MAX_HP, hitFlash: 0,
    t: 0,
    xCenter, xAmp,
    xFreq: 0.018 + Math.random() * 0.012,
    vy: 0.6,
    yAmp: 18,
    yFreq: 0.012 + Math.random() * 0.01,
    shootTimer: TANK_SHOOT_MIN + Math.floor(Math.random() * (TANK_SHOOT_MAX - TANK_SHOOT_MIN)),
  });
}

function spawnPowerup(x, y) {
  const types = ['shield', 'rapidfire', 'tripleshot', 'bomb'];
  const type  = types[Math.floor(Math.random() * types.length)];
  powerups.push({ x, y, type, vy: BASE_SCROLL * getLevelMult(), pulse: 0 });
}

// â”€â”€ Start / Reset â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startGame() {
  gameOver          = false;
  score             = 0;
  startTime         = performance.now();
  scrollY           = 0;
  enemies           = [];
  spawnTimer        = 0;
  bullets           = [];
  explosions        = [];
  enemyBullets      = [];
  tanks             = [];
  tankBullets       = [];
  tankSpawnTimer    = 0;
  obstacles         = [];
  obstacleTimer     = 0;
  lastLevel         = 1;
  bannerLevel       = 1;
  levelBannerTimer  = 0;
  shootCooldown     = 0;
  kills             = 0;
  powerups          = [];
  mines             = [];
  powerupSpawnTimer = 0;
  shieldTimer       = 0;
  rapidFireTimer    = 0;
  tripleTimer       = 0;
  bombFlash         = 0;
  player.x          = W / 2;
  player.y          = H - 140;
}

// â”€â”€ Update â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function update() {
  if (gameOver) return;

  score = Math.floor((performance.now() - startTime) / 1000);
  const mult = getLevelMult();
  const lv   = getLevel();

  // Level-up detection
  if (lv > lastLevel) {
    lastLevel        = lv;
    bannerLevel      = lv;
    levelBannerTimer = 120;
  }
  if (levelBannerTimer > 0) levelBannerTimer--;
  if (bombFlash      > 0) bombFlash--;

  scrollY += BASE_SCROLL * mult;

  if (keys['ArrowLeft']  || keys['KeyA']) player.x -= player.speed;
  if (keys['ArrowRight'] || keys['KeyD']) player.x += player.speed;
  if (keys['ArrowUp']    || keys['KeyW']) player.y -= player.speed;
  if (keys['ArrowDown']  || keys['KeyS']) player.y += player.speed;

  // Off road = game over (shield doesn't help you drive off road)
  const hw = player.w / 2, hh = player.h / 2;
  if (player.x - hw < ROAD_L || player.x + hw > ROAD_R ||
      player.y - hh < 0      || player.y + hh > H) {
    gameOver = true;
  }

  // Power-up timers
  if (shieldTimer    > 0) shieldTimer--;
  if (rapidFireTimer > 0) rapidFireTimer--;
  if (tripleTimer    > 0) tripleTimer--;

  // Spawn enemies
  const spawnInterval = Math.max(35, BASE_SPAWN_INTERVAL - (lv - 1) * 12);
  spawnTimer++;
  if (spawnTimer >= spawnInterval) { spawnEnemy(); spawnTimer = 0; }

  // Spawn tanks
  const tankInterval = Math.max(180, BASE_TANK_INTERVAL - (lv - 1) * 30);
  tankSpawnTimer++;
  if (tankSpawnTimer >= tankInterval) { spawnTank(); tankSpawnTimer = 0; }

  // Spawn obstacles
  const obstInterval = Math.max(70, BASE_OBSTACLE_INTERVAL - (lv - 1) * 18);
  obstacleTimer++;
  if (obstacleTimer >= obstInterval) { spawnObstacle(); obstacleTimer = 0; }

  // Periodic power-up spawn
  powerupSpawnTimer++;
  if (powerupSpawnTimer >= POWERUP_SPAWN_INTERVAL) {
    const px = ROAD_L + 30 + Math.random() * (ROAD_R - ROAD_L - 60);
    spawnPowerup(px, -20);
    powerupSpawnTimer = 0;
  }

  // Move obstacles & check collision
  for (let i = obstacles.length - 1; i >= 0; i--) {
    const o = obstacles[i];
    o.y += o.vy;
    if (o.y > H + 60) { obstacles.splice(i, 1); continue; }
    if (shieldTimer > 0) continue;
    if (o.type === 'barrier') {
      const gapEnd = o.gapX + o.gapW;
      if (player.y + hh > o.y && player.y - hh < o.y + o.h) {
        if (player.x - hw < o.gapX  && player.x + hw > ROAD_L + 10) gameOver = true;
        if (player.x + hw > gapEnd  && player.x - hw < ROAD_R - 10) gameOver = true;
      }
    } else {
      if (Math.abs(o.x - player.x) < (o.w + player.w) / 2 &&
          Math.abs(o.y - player.y) < (o.h + player.h) / 2) gameOver = true;
    }
  }

  // Move tanks
  for (let i = tanks.length - 1; i >= 0; i--) {
    const t = tanks[i];
    t.t++;
    if (t.hitFlash > 0) t.hitFlash--;
    t.x  = t.xCenter + Math.sin(t.t * t.xFreq) * t.xAmp;
    t.y += t.vy * mult + Math.sin(t.t * t.yFreq) * 0.4;
    if (t.y > H + 80) { tanks.splice(i, 1); continue; }

    if (shieldTimer <= 0 &&
        Math.abs(t.x - player.x) < (player.w + t.w) / 2 &&
        Math.abs(t.y - player.y) < (player.h + t.h) / 2) gameOver = true;

    t.shootTimer--;
    if (t.shootTimer <= 0) {
      const dx = player.x - t.x, dy = player.y - t.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      tankBullets.push({ x: t.x, y: t.y + t.h / 2,
        vx: (dx / dist) * TANK_BULLET_SPEED,
        vy: (dy / dist) * TANK_BULLET_SPEED });
      t.shootTimer = TANK_SHOOT_MIN + Math.floor(Math.random() * (TANK_SHOOT_MAX - TANK_SHOOT_MIN));
    }
  }

  // Move tank bullets
  for (let i = tankBullets.length - 1; i >= 0; i--) {
    const tb = tankBullets[i];
    tb.x += tb.vx; tb.y += tb.vy;
    if (tb.x < -10 || tb.x > W + 10 || tb.y > H + 10 || tb.y < -10) {
      tankBullets.splice(i, 1); continue;
    }
    if (shieldTimer <= 0 &&
        Math.abs(tb.x - player.x) < hw + 5 && Math.abs(tb.y - player.y) < hh + 5) {
      spawnExplosion(player.x, player.y); gameOver = true;
    }
  }

  // Move enemies
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];

    if (e.type === 'zigzag') {
      e.t++;
      e.x  = e.xCenter + Math.sin(e.t * e.xFreq) * e.xAmp;
      e.y += BASE_ENEMY_SPEED * mult * 1.3;
    } else if (e.type === 'bomber') {
      e.y += BASE_ENEMY_SPEED * mult * 0.7;
      e.bombTimer--;
      if (e.bombTimer <= 0) {
        mines.push({ x: e.x, y: e.y + e.h / 2, w: 18, h: 18,
          vy: BASE_SCROLL * mult * 0.7, pulse: 0 });
        e.bombTimer = 80 + Math.floor(Math.random() * 60);
      }
    } else if (e.type === 'armored') {
      if (e.hitFlash > 0) e.hitFlash--;
      e.y += BASE_ENEMY_SPEED * mult * 0.85;
    } else {
      e.y += BASE_ENEMY_SPEED * mult;
    }

    if (e.y > H + 50) { enemies.splice(i, 1); continue; }
    if (shieldTimer <= 0 &&
        Math.abs(e.x - player.x) < (player.w + e.w) / 2 &&
        Math.abs(e.y - player.y) < (player.h + e.h) / 2) gameOver = true;
  }

  // Enemy shooting
  enemies.forEach(e => {
    if (e.type === 'bomber') return; // bombers drop mines instead
    e.shootTimer--;
    if (e.shootTimer <= 0) {
      if (e.type === 'armored') {
        // Armored shoots two bullets
        enemyBullets.push({ x: e.x - 8, y: e.y + e.h / 2 });
        enemyBullets.push({ x: e.x + 8, y: e.y + e.h / 2 });
      } else {
        enemyBullets.push({ x: e.x, y: e.y + e.h / 2 });
      }
      e.shootTimer = ENEMY_SHOOT_MIN + Math.floor(Math.random() * (ENEMY_SHOOT_MAX - ENEMY_SHOOT_MIN));
    }
  });

  // Move enemy bullets
  for (let i = enemyBullets.length - 1; i >= 0; i--) {
    const eb = enemyBullets[i];
    eb.y += ENEMY_BULLET_SPEED;
    if (eb.y > H + 10) { enemyBullets.splice(i, 1); continue; }
    if (shieldTimer <= 0 &&
        Math.abs(eb.x - player.x) < hw + 5 && Math.abs(eb.y - player.y) < hh + 5) {
      spawnExplosion(player.x, player.y); gameOver = true;
    }
  }

  // Move mines
  for (let i = mines.length - 1; i >= 0; i--) {
    const m = mines[i];
    m.y    += m.vy;
    m.pulse = (m.pulse || 0) + 0.08;
    if (m.y > H + 30) { mines.splice(i, 1); continue; }
    if (shieldTimer <= 0 &&
        Math.abs(m.x - player.x) < (m.w + player.w) / 2 &&
        Math.abs(m.y - player.y) < (m.h + player.h) / 2) {
      spawnExplosion(player.x, player.y); gameOver = true;
    }
  }

  // Move power-ups & collect
  for (let i = powerups.length - 1; i >= 0; i--) {
    const p = powerups[i];
    p.y    += p.vy;
    p.pulse = (p.pulse || 0) + 0.07;
    if (p.y > H + 30) { powerups.splice(i, 1); continue; }
    if (Math.abs(p.x - player.x) < (22 + hw) &&
        Math.abs(p.y - player.y) < (22 + hh)) {
      if      (p.type === 'shield')    shieldTimer    = SHIELD_DURATION;
      else if (p.type === 'rapidfire') rapidFireTimer = POWERUP_DURATION;
      else if (p.type === 'tripleshot') tripleTimer   = POWERUP_DURATION;
      else if (p.type === 'bomb') {
        enemies.forEach(e => spawnExplosion(e.x, e.y));
        tanks.forEach(t => {
          spawnExplosion(t.x, t.y - 10);
          spawnExplosion(t.x - 14, t.y + 8);
          spawnExplosion(t.x + 14, t.y + 8);
        });
        kills   += enemies.length + tanks.length * 5;
        enemies  = []; tanks = []; tankBullets = [];
        enemyBullets = []; mines = [];
        bombFlash = 22;
      }
      powerups.splice(i, 1);
    }
  }

  // Player shoot
  if (shootCooldown > 0) shootCooldown--;
  const activeCooldown = rapidFireTimer > 0 ? Math.ceil(SHOOT_COOLDOWN / 2) : SHOOT_COOLDOWN;
  if (keys['Space'] && shootCooldown === 0) {
    if (tripleTimer > 0) {
      bullets.push({ x: player.x - 12, y: player.y - hh });
      bullets.push({ x: player.x,      y: player.y - hh });
      bullets.push({ x: player.x + 12, y: player.y - hh });
    } else {
      bullets.push({ x: player.x, y: player.y - hh });
    }
    shootCooldown = activeCooldown;
  }

  // Move bullets & collisions
  for (let bi = bullets.length - 1; bi >= 0; bi--) {
    const b = bullets[bi];
    b.y -= BULLET_SPEED;
    if (b.y < -10) { bullets.splice(bi, 1); continue; }
    let hit = false;

    // Mines
    for (let mi = mines.length - 1; mi >= 0; mi--) {
      const m = mines[mi];
      if (Math.abs(b.x - m.x) < m.w / 2 + 4 && Math.abs(b.y - m.y) < m.h / 2 + 4) {
        spawnExplosion(m.x, m.y);
        mines.splice(mi, 1); bullets.splice(bi, 1);
        kills++; hit = true; break;
      }
    }
    if (hit) continue;

    // Enemies
    for (let ei = enemies.length - 1; ei >= 0; ei--) {
      const e = enemies[ei];
      if (Math.abs(b.x - e.x) < e.w / 2 + 4 && Math.abs(b.y - e.y) < e.h / 2 + 4) {
        if (e.type === 'armored') {
          e.hp--; e.hitFlash = 8;
          bullets.splice(bi, 1);
          if (e.hp <= 0) {
            spawnExplosion(e.x, e.y);
            if (Math.random() < ENEMY_DROP_CHANCE * 1.5) spawnPowerup(e.x, e.y);
            enemies.splice(ei, 1);
            kills += 3;
          }
        } else {
          spawnExplosion(e.x, e.y);
          if (Math.random() < ENEMY_DROP_CHANCE) spawnPowerup(e.x, e.y);
          enemies.splice(ei, 1); bullets.splice(bi, 1);
          kills += (e.type === 'zigzag' || e.type === 'bomber') ? 2 : 1;
        }
        hit = true; break;
      }
    }
    if (hit) continue;

    // Tanks
    for (let ti = tanks.length - 1; ti >= 0; ti--) {
      const t = tanks[ti];
      if (Math.abs(b.x - t.x) < t.w / 2 + 4 && Math.abs(b.y - t.y) < t.h / 2 + 4) {
        t.hp--; t.hitFlash = 8; bullets.splice(bi, 1);
        if (t.hp <= 0) {
          spawnExplosion(t.x, t.y - 10);
          spawnExplosion(t.x - 14, t.y + 8);
          spawnExplosion(t.x + 14, t.y + 8);
          if (Math.random() < ENEMY_DROP_CHANCE * 2) spawnPowerup(t.x, t.y);
          tanks.splice(ti, 1);
          kills += 5;
        }
        hit = true; break;
      }
    }
    if (hit) continue;
  }

  // Update explosions
  for (let i = explosions.length - 1; i >= 0; i--) {
    const ex = explosions[i];
    ex.life--;
    if (ex.life <= 0) { explosions.splice(i, 1); continue; }
    ex.particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.vy += 0.12; });
  }
}

// â”€â”€ Draw helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawRoad() {
  ctx.fillStyle = '#2d7a3a';
  ctx.fillRect(0, 0, W, H);

  const stripeSpacing = 80;
  const stripeOffset  = scrollY % stripeSpacing;
  ctx.fillStyle = '#255e30';
  for (let y = -stripeSpacing + stripeOffset; y < H + stripeSpacing; y += stripeSpacing) {
    ctx.fillRect(0,      y, ROAD_L, 12);
    ctx.fillRect(ROAD_R, y, W - ROAD_R, 12);
  }

  const postSpacing = 120;
  const postOffset  = scrollY % postSpacing;
  for (let y = -postSpacing + postOffset; y < H + postSpacing; y += postSpacing) {
    ctx.fillStyle = '#cccccc';
    ctx.fillRect(ROAD_L - 14, y - 18, 7, 36);
    ctx.fillRect(ROAD_R +  7, y - 18, 7, 36);
    ctx.fillStyle = '#FFD60A';
    ctx.fillRect(ROAD_L - 12, y - 4, 3, 8);
    ctx.fillRect(ROAD_R +  9, y - 4, 3, 8);
  }

  ctx.fillStyle = '#484848';
  ctx.fillRect(ROAD_L, 0, ROAD_R - ROAD_L, H);

  const rumbleSpacing = 40;
  const rumbleOffset  = scrollY % (rumbleSpacing * 2);
  for (let y = -rumbleSpacing * 2 + rumbleOffset; y < H + rumbleSpacing * 2; y += rumbleSpacing) {
    const col = Math.floor(y / rumbleSpacing) % 2 === 0 ? '#ff4444' : '#ffffff';
    ctx.fillStyle = col;
    ctx.fillRect(ROAD_L,      y, 10, rumbleSpacing);
    ctx.fillRect(ROAD_R - 10, y, 10, rumbleSpacing);
  }

  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(ROAD_L + 10, 0); ctx.lineTo(ROAD_L + 10, H);
  ctx.moveTo(ROAD_R - 10, 0); ctx.lineTo(ROAD_R - 10, H);
  ctx.stroke();

  ctx.strokeStyle = '#FFD60A';
  ctx.lineWidth = 3;
  ctx.setLineDash([40, 40]);
  ctx.lineDashOffset = -(scrollY % 80);
  ctx.beginPath();
  ctx.moveTo(W / 2, 0); ctx.lineTo(W / 2, H);
  ctx.stroke();
  ctx.setLineDash([]);
}

function drawEnemyCar(e) {
  const { x, y, w, h, type } = e;
  const hw = w / 2, hh = h / 2;
  const ww = 8, wh = 14;

  if (type === 'zigzag') {
    // Purple zigzag racer
    ctx.fillStyle = '#7C3AED';
    ctx.fillRect(x - hw, y - hh, w, h);
    ctx.fillStyle = 'rgba(40,0,80,0.9)';
    ctx.fillRect(x - hw + 5, y + hh - 7 - h * 0.28, w - 10, h * 0.28);
    ctx.fillStyle = 'rgba(100,20,180,0.7)';
    ctx.fillRect(x - hw + 5, y - hh + 7, w - 10, h * 0.18);
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(x - hw - ww + 1, y - hh + 7,      ww, wh);
    ctx.fillRect(x + hw - 1,      y - hh + 7,      ww, wh);
    ctx.fillRect(x - hw - ww + 1, y + hh - 7 - wh, ww, wh);
    ctx.fillRect(x + hw - 1,      y + hh - 7 - wh, ww, wh);
    ctx.fillStyle = '#cc88ff';
    ctx.fillRect(x - hw + 4,  y + hh - 4, 8, 4);
    ctx.fillRect(x + hw - 12, y + hh - 4, 8, 4);
    // Side speed streaks
    ctx.fillStyle = 'rgba(160,0,255,0.28)';
    ctx.fillRect(x - hw - 5, y - hh + 6, 5, h - 12);
    ctx.fillRect(x + hw,     y - hh + 6, 5, h - 12);

  } else if (type === 'armored') {
    // Steel armored car â€” multi-hit
    const flash = e.hitFlash > 0;
    ctx.fillStyle = flash ? '#e5e7eb' : '#6b7280';
    ctx.fillRect(x - hw, y - hh, w, h);
    if (!flash) {
      ctx.fillStyle = '#374151';
      ctx.fillRect(x - hw + 2, y - hh + 2,  w - 4, 7);
      ctx.fillRect(x - hw + 2, y + hh - 9,  w - 4, 7);
      ctx.fillRect(x - hw + 2, y - 4,       w - 4, 8);
    }
    ctx.fillStyle = flash ? 'rgba(255,255,255,0.85)' : 'rgba(20,20,20,0.9)';
    ctx.fillRect(x - hw + 5, y + hh - 7 - h * 0.28, w - 10, h * 0.28);
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(x - hw - ww + 1, y - hh + 7,      ww, wh);
    ctx.fillRect(x + hw - 1,      y - hh + 7,      ww, wh);
    ctx.fillRect(x - hw - ww + 1, y + hh - 7 - wh, ww, wh);
    ctx.fillRect(x + hw - 1,      y + hh - 7 - wh, ww, wh);
    ctx.fillStyle = '#ef4444';
    ctx.fillRect(x - hw + 4,  y + hh - 4, 8, 4);
    ctx.fillRect(x + hw - 12, y + hh - 4, 8, 4);
    // HP pips above car
    for (let hp = 0; hp < e.hp; hp++) {
      ctx.fillStyle = '#4ade80';
      ctx.fillRect(x - hw + 4 + hp * 12, y - hh - 9, 9, 6);
    }

  } else if (type === 'bomber') {
    // Dark orange bomber â€” drops mines
    ctx.fillStyle = '#c2410c';
    ctx.fillRect(x - hw, y - hh, w, h);
    ctx.fillStyle = 'rgba(70,15,0,0.9)';
    ctx.fillRect(x - hw + 5, y + hh - 7 - h * 0.28, w - 10, h * 0.28);
    ctx.fillStyle = 'rgba(120,40,0,0.7)';
    ctx.fillRect(x - hw + 5, y - hh + 7, w - 10, h * 0.18);
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(x - hw - ww + 1, y - hh + 7,      ww, wh);
    ctx.fillRect(x + hw - 1,      y - hh + 7,      ww, wh);
    ctx.fillRect(x - hw - ww + 1, y + hh - 7 - wh, ww, wh);
    ctx.fillRect(x + hw - 1,      y + hh - 7 - wh, ww, wh);
    ctx.fillStyle = '#fb923c';
    ctx.fillRect(x - hw + 4,  y + hh - 4, 8, 4);
    ctx.fillRect(x + hw - 12, y + hh - 4, 8, 4);
    // Bomb-bay dot
    ctx.fillStyle = '#ff6600';
    ctx.beginPath(); ctx.arc(x, y + 6, 6, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#111';
    ctx.beginPath(); ctx.arc(x, y + 6, 3, 0, Math.PI * 2); ctx.fill();

  } else {
    // Normal (dark red)
    ctx.fillStyle = '#CC1100';
    ctx.fillRect(x - hw, y - hh, w, h);
    ctx.fillStyle = 'rgba(60,10,10,0.9)';
    ctx.fillRect(x - hw + 5, y + hh - 7 - h * 0.28, w - 10, h * 0.28);
    ctx.fillStyle = 'rgba(110,20,20,0.7)';
    ctx.fillRect(x - hw + 5, y - hh + 7, w - 10, h * 0.18);
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(x - hw - ww + 1, y - hh + 7,      ww, wh);
    ctx.fillRect(x + hw - 1,      y - hh + 7,      ww, wh);
    ctx.fillRect(x - hw - ww + 1, y + hh - 7 - wh, ww, wh);
    ctx.fillRect(x + hw - 1,      y + hh - 7 - wh, ww, wh);
    ctx.fillStyle = '#ff6666';
    ctx.fillRect(x - hw + 4,  y + hh - 4, 8, 4);
    ctx.fillRect(x + hw - 12, y + hh - 4, 8, 4);
  }
}

function spawnExplosion(x, y) {
  const COLORS = ['#FF4444', '#FF6B35', '#FFD60A', '#ffffff', '#FF8800'];
  const particles = [];
  for (let i = 0; i < 12; i++) {
    const angle = (Math.PI * 2 * i) / 12 + Math.random() * 0.4;
    const speed = 2 + Math.random() * 3.5;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed - 1.5,
      color: COLORS[Math.floor(Math.random() * COLORS.length)],
      size: 3 + Math.random() * 5,
    });
  }
  explosions.push({ particles, life: 28 });
}

function drawBullets() {
  bullets.forEach(b => {
    ctx.save();
    ctx.shadowBlur  = 10;
    ctx.shadowColor = '#FFD60A';
    ctx.fillStyle   = '#FFD60A';
    ctx.fillRect(b.x - 3, b.y - 10, 6, 18);
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(b.x - 1.5, b.y - 10, 3, 6);
    ctx.restore();
  });
}

function drawEnemyBullets() {
  enemyBullets.forEach(eb => {
    ctx.save();
    ctx.shadowBlur  = 10;
    ctx.shadowColor = '#FF2D78';
    ctx.fillStyle   = '#FF2D78';
    ctx.fillRect(eb.x - 3, eb.y, 6, 18);
    ctx.fillStyle = '#ffaacc';
    ctx.fillRect(eb.x - 1.5, eb.y + 12, 3, 6);
    ctx.restore();
  });
}

function drawTank(t) {
  const { x, y, w, h, hp, hitFlash } = t;
  const hw = w / 2, hh = h / 2;
  const flash = hitFlash > 0;

  ctx.fillStyle = flash ? '#cc6666' : '#2a2a2a';
  ctx.fillRect(x - hw - 7, y - hh + 4, 9, h - 8);
  ctx.fillRect(x + hw - 2, y - hh + 4, 9, h - 8);
  if (!flash) {
    ctx.fillStyle = '#444';
    for (let ty = y - hh + 6; ty < y + hh - 8; ty += 9) {
      ctx.fillRect(x - hw - 6, ty, 7, 5);
      ctx.fillRect(x + hw - 1, ty, 7, 5);
    }
  }

  ctx.fillStyle = flash ? '#ff7777' : '#4a5e2a';
  ctx.fillRect(x - hw, y - hh, w, h);
  if (!flash) {
    ctx.fillStyle = '#3a4d1f';
    ctx.fillRect(x - hw + 4, y - hh + 4, w - 8, 5);
    ctx.fillRect(x - hw + 4, y + hh - 9, w - 8, 5);
  }

  ctx.fillStyle = flash ? '#ff5555' : '#3a4a1e';
  ctx.fillRect(x - 15, y - 14, 30, 26);

  ctx.fillStyle = flash ? '#ff5555' : '#2a3515';
  ctx.fillRect(x - 4, y + 10, 8, 24);
  ctx.fillStyle = flash ? '#ffaaaa' : '#1a2510';
  ctx.fillRect(x - 5, y + 30, 10, 6);

  const barW = w + 10, barH = 7;
  const barX = x - barW / 2, barY = y - hh - 14;
  ctx.fillStyle = '#222';
  ctx.fillRect(barX, barY, barW, barH);
  const hpFrac = hp / TANK_MAX_HP;
  ctx.fillStyle = hpFrac > 0.6 ? '#44dd44' : hpFrac > 0.3 ? '#FFD60A' : '#FF4444';
  ctx.fillRect(barX, barY, barW * hpFrac, barH);
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 1;
  ctx.strokeRect(barX, barY, barW, barH);

  ctx.fillStyle = '#fff';
  ctx.font = 'bold 9px monospace';
  ctx.textAlign = 'center';
  ctx.fillText(hp + '/' + TANK_MAX_HP, x, barY - 2);
  ctx.textAlign = 'left';
}

function drawTankBullets() {
  tankBullets.forEach(tb => {
    ctx.save();
    ctx.shadowBlur  = 12;
    ctx.shadowColor = '#FF8800';
    ctx.fillStyle   = '#FF8800';
    ctx.beginPath(); ctx.arc(tb.x, tb.y, 5, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#FFD60A';
    ctx.beginPath(); ctx.arc(tb.x, tb.y, 2.5, 0, Math.PI * 2); ctx.fill();
    ctx.restore();
  });
}

function drawExplosions() {
  explosions.forEach(ex => {
    const alpha = ex.life / 28;
    ex.particles.forEach(p => {
      ctx.globalAlpha = alpha;
      ctx.fillStyle   = p.color;
      ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
    });
  });
  ctx.globalAlpha = 1;
}

function drawMine(m) {
  const pulse = Math.sin(m.pulse) * 0.35 + 0.65;
  ctx.save();
  ctx.shadowBlur  = 14;
  ctx.shadowColor = '#FF3300';
  // Outer ring
  ctx.strokeStyle = `rgba(255,80,0,${pulse})`;
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.arc(m.x, m.y, 12, 0, Math.PI * 2); ctx.stroke();
  // Body
  ctx.fillStyle = '#2a2a2a';
  ctx.beginPath(); ctx.arc(m.x, m.y, 9, 0, Math.PI * 2); ctx.fill();
  // Spikes
  ctx.fillStyle = '#555';
  for (let i = 0; i < 8; i++) {
    const a = (Math.PI * 2 * i) / 8;
    ctx.fillRect(m.x + Math.cos(a) * 7 - 2, m.y + Math.sin(a) * 7 - 2, 4, 4);
  }
  // Blinking center
  ctx.fillStyle = `rgba(255,${Math.floor(pulse * 80)},0,${pulse})`;
  ctx.beginPath(); ctx.arc(m.x, m.y, 4, 0, Math.PI * 2); ctx.fill();
  ctx.restore();
}

const POWERUP_COLORS = {
  shield:     '#00E5FF',
  rapidfire:  '#FFD60A',
  tripleshot: '#06D6A0',
  bomb:       '#FF6B35',
};
const POWERUP_ICONS = {
  shield:     'ðŸ›¡',
  rapidfire:  'âš¡',
  tripleshot: 'ðŸ”±',
  bomb:       'ðŸ’£',
};

function drawPowerup(p) {
  const color = POWERUP_COLORS[p.type];
  const pulse = Math.sin(p.pulse) * 0.25 + 0.75;
  ctx.save();
  ctx.shadowBlur  = 18;
  ctx.shadowColor = color;
  ctx.strokeStyle = color;
  ctx.lineWidth   = 2;
  ctx.globalAlpha = pulse;
  ctx.beginPath(); ctx.arc(p.x, p.y, 16, 0, Math.PI * 2); ctx.stroke();
  ctx.globalAlpha = 0.28 * pulse;
  ctx.fillStyle   = color;
  ctx.beginPath(); ctx.arc(p.x, p.y, 14, 0, Math.PI * 2); ctx.fill();
  ctx.globalAlpha = pulse;
  ctx.font = '14px serif';
  ctx.textAlign    = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(POWERUP_ICONS[p.type], p.x, p.y);
  ctx.textBaseline = 'alphabetic';
  ctx.textAlign    = 'left';
  ctx.restore();
}

function drawPowerupIndicator(icon, color, timer, maxTimer, x, y) {
  const frac = timer / maxTimer;
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.65)';
  ctx.beginPath(); ctx.roundRect(x, y, 62, 22, 6); ctx.fill();
  ctx.globalAlpha = 0.35;
  ctx.fillStyle = color;
  ctx.fillRect(x + 2, y + 2, (58) * frac, 18);
  ctx.globalAlpha = 1;
  ctx.strokeStyle = color;
  ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.roundRect(x, y, 62, 22, 6); ctx.stroke();
  ctx.font = '12px serif';
  ctx.textAlign = 'left';
  ctx.fillText(icon, x + 5, y + 15);
  ctx.font = 'bold 10px monospace';
  ctx.fillStyle = '#fff';
  ctx.fillText(Math.ceil(timer / 60) + 's', x + 26, y + 15);
  ctx.restore();
}

function drawBarrierSegment(x, y, w, h) {
  if (w <= 0) return;
  ctx.save();
  ctx.beginPath(); ctx.rect(x, y, w, h); ctx.clip();
  const sW = h * 1.2;
  for (let i = -h; i < w + h; i += sW) {
    ctx.fillStyle = Math.floor(i / sW) % 2 === 0 ? '#EE2222' : '#ffffff';
    ctx.fillRect(x + i, y, sW, h + 1);
  }
  ctx.restore();
  ctx.strokeStyle = '#991111'; ctx.lineWidth = 2;
  ctx.strokeRect(x, y, w, h);
}

function drawObstacle(o) {
  if (o.type === 'cone') {
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.beginPath(); ctx.ellipse(o.x, o.y + o.h / 2 + 2, o.w / 2, 4, 0, 0, Math.PI * 2); ctx.fill();
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(o.x, o.y - o.h / 2);
    ctx.lineTo(o.x - o.w / 2, o.y + o.h / 2);
    ctx.lineTo(o.x + o.w / 2, o.y + o.h / 2);
    ctx.closePath(); ctx.clip();
    ctx.fillStyle = '#FF6B00'; ctx.fillRect(o.x - o.w, o.y - o.h, o.w * 2, o.h * 2);
    ctx.fillStyle = '#fff';    ctx.fillRect(o.x - o.w / 2, o.y - 3, o.w, 6);
    ctx.restore();
    ctx.fillStyle = '#882200';
    ctx.fillRect(o.x - o.w / 2, o.y + o.h / 2 - 5, o.w, 5);
  } else if (o.type === 'oil') {
    const grd = ctx.createRadialGradient(o.x - 8, o.y - 4, 2, o.x, o.y, o.w / 2);
    grd.addColorStop(0,    'rgba(100,0,130,0.95)');
    grd.addColorStop(0.25, 'rgba(0,20,160,0.80)');
    grd.addColorStop(0.55, 'rgba(0,120,20,0.55)');
    grd.addColorStop(0.8,  'rgba(80,80,0,0.30)');
    grd.addColorStop(1,    'rgba(0,0,0,0)');
    ctx.fillStyle = grd;
    ctx.beginPath(); ctx.ellipse(o.x, o.y, o.w / 2, o.h / 2, 0, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    ctx.beginPath(); ctx.ellipse(o.x - 8, o.y - 4, 14, 5, -0.3, 0, Math.PI * 2); ctx.fill();
  } else {
    drawBarrierSegment(ROAD_L + 10, o.y, o.gapX - (ROAD_L + 10), o.h);
    drawBarrierSegment(o.gapX + o.gapW, o.y, (ROAD_R - 10) - (o.gapX + o.gapW), o.h);
    ctx.fillStyle = 'rgba(255,255,255,0.7)';
    ctx.font = 'bold 14px monospace'; ctx.textAlign = 'center';
    ctx.fillText('â–¼', o.gapX + o.gapW / 2, o.y + o.h / 2 + 6);
    ctx.textAlign = 'left';
  }
}

function drawLevelBanner() {
  if (levelBannerTimer <= 0) return;
  const alpha = Math.min(1, levelBannerTimer / 20);
  ctx.save();
  ctx.globalAlpha = alpha;
  const bw = 280, bh = 72;
  ctx.fillStyle = 'rgba(0,0,0,0.72)';
  ctx.beginPath(); ctx.roundRect(W / 2 - bw / 2, H / 2 - bh / 2, bw, bh, 12); ctx.fill();
  ctx.strokeStyle = '#06D6A0'; ctx.lineWidth = 3;
  ctx.beginPath(); ctx.roundRect(W / 2 - bw / 2, H / 2 - bh / 2, bw, bh, 12); ctx.stroke();
  ctx.fillStyle = '#06D6A0';
  ctx.font = 'bold 14px monospace'; ctx.textAlign = 'center';
  ctx.fillText('âš¡ LEVEL UP âš¡', W / 2, H / 2 - 10);
  ctx.fillStyle = '#FFD60A';
  ctx.font = 'bold 38px monospace';
  ctx.fillText('LEVEL ' + bannerLevel, W / 2, H / 2 + 26);
  ctx.textAlign = 'left';
  ctx.restore();
}

function drawCar(x, y, w, h, color) {
  const hw = w / 2, hh = h / 2;

  ctx.fillStyle = color;
  ctx.fillRect(x - hw, y - hh, w, h);

  ctx.fillStyle = 'rgba(180,230,255,0.75)';
  ctx.fillRect(x - hw + 5, y - hh + 7, w - 10, h * 0.28);

  ctx.fillStyle = 'rgba(140,200,240,0.6)';
  ctx.fillRect(x - hw + 5, y + hh - 7 - h * 0.2, w - 10, h * 0.18);

  ctx.fillStyle = '#1a1a1a';
  const ww = 8, wh = 14;
  ctx.fillRect(x - hw - ww + 1, y - hh + 7,      ww, wh);
  ctx.fillRect(x + hw - 1,      y - hh + 7,      ww, wh);
  ctx.fillRect(x - hw - ww + 1, y + hh - 7 - wh, ww, wh);
  ctx.fillRect(x + hw - 1,      y + hh - 7 - wh, ww, wh);

  ctx.fillStyle = '#ffffa0';
  ctx.fillRect(x - hw + 4,  y - hh, 8, 4);
  ctx.fillRect(x + hw - 12, y - hh, 8, 4);
}

function drawShield(x, y) {
  const t = performance.now() / 400;
  const pulse = Math.sin(t) * 0.2 + 0.8;
  ctx.save();
  ctx.shadowBlur  = 20;
  ctx.shadowColor = '#00E5FF';
  ctx.strokeStyle = `rgba(0,229,255,${pulse})`;
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.ellipse(x, y, player.w / 2 + 12, player.h / 2 + 12, 0, 0, Math.PI * 2);
  ctx.stroke();
  ctx.globalAlpha = 0.12 * pulse;
  ctx.fillStyle = '#00E5FF';
  ctx.beginPath();
  ctx.ellipse(x, y, player.w / 2 + 12, player.h / 2 + 12, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

function elapsedStr() {
  const t  = Math.floor((performance.now() - startTime) / 1000);
  const mm = String(Math.floor(t / 60)).padStart(2, '0');
  const ss = String(t % 60).padStart(2, '0');
  return mm + ':' + ss;
}

function drawHUD() {
  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  ctx.fillRect(0, 0, W, 50);

  ctx.font = 'bold 16px monospace';

  ctx.textAlign = 'left';
  ctx.fillStyle = '#06D6A0';
  ctx.fillText('LV.' + getLevel(), 10, 28);

  const curScore = score + kills * 5;
  ctx.fillStyle = '#fff';
  ctx.fillText(curScore, 68, 28);
  ctx.fillStyle = 'rgba(255,214,10,0.6)';
  ctx.font = 'bold 11px monospace';
  ctx.fillText('BEST ' + Math.max(highScore, curScore), 68, 42);
  ctx.font = 'bold 16px monospace';

  ctx.textAlign = 'center';
  ctx.fillStyle = '#FFD60A';
  ctx.fillText('ðŸ’¥ ' + kills, W / 2, 28);

  ctx.textAlign = 'right';
  ctx.fillStyle = '#fff';
  ctx.fillText(elapsedStr(), W - 10, 28);
  ctx.textAlign = 'left';

  // Active power-up indicators (bottom-left, above hint bar)
  let ix = 8;
  const iy = H - 52;
  if (shieldTimer > 0) {
    drawPowerupIndicator('ðŸ›¡', '#00E5FF', shieldTimer, SHIELD_DURATION, ix, iy);
    ix += 68;
  }
  if (rapidFireTimer > 0) {
    drawPowerupIndicator('âš¡', '#FFD60A', rapidFireTimer, POWERUP_DURATION, ix, iy);
    ix += 68;
  }
  if (tripleTimer > 0) {
    drawPowerupIndicator('ðŸ”±', '#06D6A0', tripleTimer, POWERUP_DURATION, ix, iy);
  }

  // Bottom hint bar
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.fillRect(0, H - 26, W, 26);
  ctx.fillStyle = 'rgba(255,214,10,0.8)';
  ctx.font = 'bold 11px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('SPACE â€” shoot  Â·  ARROWS / WASD â€” move', W / 2, H - 8);
  ctx.textAlign = 'left';
}

function drawGameOver() {
  const finalScore = score + kills * 5;
  const isNewBest  = finalScore > highScore;
  if (isNewBest) {
    highScore = finalScore;
    localStorage.setItem('xancars_hs', highScore);
  }

  ctx.fillStyle = 'rgba(0,0,0,0.68)';
  ctx.fillRect(0, 0, W, H);

  const ph = isNewBest ? 290 : 265;
  const px = W/2 - 160, py = H/2 - ph / 2, pw = 320;
  ctx.fillStyle = '#1a1a2e';
  ctx.beginPath(); ctx.roundRect(px, py, pw, ph, 14); ctx.fill();
  ctx.strokeStyle = isNewBest ? '#FFD60A' : '#FF4444';
  ctx.lineWidth = 3;
  ctx.beginPath(); ctx.roundRect(px, py, pw, ph, 14); ctx.stroke();

  ctx.textAlign = 'center';

  ctx.fillStyle = '#FF4444';
  ctx.font = 'bold 40px monospace';
  ctx.fillText('GAME OVER', W/2, py + 52);

  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 19px monospace';
  ctx.fillText('Score: ' + finalScore, W/2, py + 100);
  ctx.fillText('Time:  ' + elapsedStr(), W/2, py + 126);
  ctx.fillStyle = '#FFD60A';
  ctx.fillText('Kills: ' + kills, W/2, py + 152);

  if (isNewBest) {
    ctx.fillStyle = '#FFD60A';
    ctx.font = 'bold 15px monospace';
    ctx.fillText('ðŸ†  NEW BEST: ' + highScore + '  ðŸ†', W/2, py + 182);
  } else {
    ctx.fillStyle = 'rgba(255,255,255,0.45)';
    ctx.font = '14px monospace';
    ctx.fillText('Best: ' + highScore, W/2, py + 182);
  }

  const btnY = py + ph - 66;
  ctx.fillStyle = '#FFD60A';
  ctx.beginPath(); ctx.roundRect(W/2 - 90, btnY, 180, 44, 10); ctx.fill();
  ctx.fillStyle = '#1a1a1a';
  ctx.font = 'bold 18px monospace';
  ctx.fillText('â–¶  RESTART', W/2, btnY + 28);

  ctx.fillStyle = 'rgba(255,255,255,0.45)';
  ctx.font = '12px monospace';
  ctx.fillText('or press Enter / Space', W/2, btnY + 52);

  ctx.textAlign = 'left';
}

// â”€â”€ Loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function loop() {
  update();
  ctx.clearRect(0, 0, W, H);

  // Bomb flash overlay
  if (bombFlash > 0) {
    ctx.fillStyle = `rgba(255,140,0,${bombFlash / 22 * 0.55})`;
    ctx.fillRect(0, 0, W, H);
  }

  drawRoad();
  obstacles.forEach(o => drawObstacle(o));
  mines.forEach(m => drawMine(m));
  powerups.forEach(p => drawPowerup(p));
  enemies.forEach(e => drawEnemyCar(e));
  tanks.forEach(t => drawTank(t));
  drawBullets();
  drawEnemyBullets();
  drawTankBullets();
  drawExplosions();
  drawCar(player.x, player.y, player.w, player.h, '#4361EE');
  if (shieldTimer > 0) drawShield(player.x, player.y);
  drawHUD();
  drawLevelBanner();
  if (gameOver) drawGameOver();
  requestAnimationFrame(loop);
}

startGame();
requestAnimationFrame(loop);
</script>
</body>
</html>
